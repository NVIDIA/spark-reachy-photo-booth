# Cursor Rules for ui-frontend directory

You are an expert in React 19, TypeScript, Vite, and Tailwind CSS 4.

## Project description

This project is a UI for an interactive robot (Reachy). It displays the robot's video stream, renders pictures captured by the robot, and images generated by the robot's AI. It also renders transcripts for the user's and the robot's speeches, as well as a colored frame indicating various backend states (robot thinking, user speaking, etc).

## Tech Stack

- **Framework**: React 19
- **Build Tool**: Vite 7
- **Styling**: Tailwind CSS 4
- **Language**: TypeScript

## Coding Guidelines

1. When working on this project, the most important factor is code readability and simplicity.
2. Do not add features that the user has not requested.
3. Only add comments if they explain something that the reader would not clearly understand from reading the code (prefer "why" vs "what").
4. Avoid importing third-party libraries. Only use third-party libraries if a hand-written solution would be very costly to maintain. If importing third-party libraries, only use ones that have a permissive license.
5. The UI runs in a very controlled environment. It is fully speech enabled (controlled by the backend), and therefore requires no interaction with the keyboard, mouse or screen reader. You needn't care for accessibility features. It will never be published on the public internet, so SEO is not a concern, and the network can be considered reliable (no need for retries, or deal with specific WebRTC edge cases). It runs in a very recent version of Firefox. You do not need to use vendor prefixes for compatibility with other browsers. You do not need to make buttons, care about focus rings, hover/focus/active states, etc.

### React Components

- Use functional components with `React.FC` or directly typed props.
- Use strict TypeScript types. Avoid `any`.
- Use React 19 best practices.
- Don't use React SWC, server-side rendering, or obscure React APIs (e.g. `useImperativeHandle` or `dangerouslySetInnerHTML`).

### Styling (Tailwind CSS 4)

- Use utility classes directly in `className`.
- For conditional classes and combining classes, use the `classnames` library (already installed).
- Follow Tailwind 4 conventions.
- Prefer using CSS for animations. JavaScript-based animations should only be used when CSS animations would severely hinder readability. When possible, use tailwind's built-in animations utilities (`animate-ping`, `animate-bounce`, etc). If not possible, write the animation keyframes in index.css. Avoid shady tricks like rendering `<style />` elements directly in React.
- Components should handle their own styles, but are not responsible for their layout (width, height, position, etc). Their parent component (typically `App.tsx`) should be responsible for that. The parent component sets these classes using `className`. The child is responsible for merging these classes using the `classnames` library.
- Avoid manually setting z-indexes. Leverage the browser's layering order instead.
- All fonts and sizes should scale with the viewport. As such, always use `vh` and `vw` units for fonts. When determining the size of an element, never hardcode dimensions in fixed units. Use `%`, `vh` and `vw` units instead, or tailwind's `w-x/y` classes.

### File Structure

- Split components into their own files. All component files should be placed in the src/ directory (not in dedicated subdirectories).
- Hooks should live in the src/hooks directory.
- Utility functions should live in the src/utils directory.
- Assets (such as images) should live in the src/assets/ directory.
- The app has a `FloatingImages` component that renders images. These floating images live in the `src/assets/pre-generated-images` directory. If you are requested to change the set of images, make sure to update the animation duration in `.animate-float-up` and the middle step of the `floatUp` keyframes to match the new number of images.

### State Management

- This project should hold very little state. The whole app should behave as a function of the state it receives from the websocket (see `useWebsocket()` in the `App.tsx` component). If complex state is required, it should live in the server (see the `ui-server-service` project).
- In some cases, keeping state in the UI is more reasonable (e.g. small cosmetic states that are scoped to a single component). In these cases, use `useState`. Avoid the Context API. External libraries such as redux and zustand are strictly forbidden.
- Custom hooks should be placed in `src/hooks`.

### Performance

- Prefer readability over excessive performance optimization. Avoid APIs such as `useMemo` and `useCallback` unless there is an unmistakable performance concern, or if referential equality is strictly necessary.
